

- Readers-Writers Problem using Threads and Mutex

CODE - 
cpp
#include <stdio.h>
#include <stdbool.h>

struct semaphore {
    int mutex;   // 1: available, 0: in use
    int rcount;  // Number of active readers
    int rwait;   // Number of waiting readers
    bool wrt;    // Writer active flag
};

// Function to add a reader
void addR(struct semaphore *s) {
    if (s->mutex == 0 && s->rcount == 0) {
        printf("\nSorry, File open in Write mode.\nNew Reader added to queue.\n");
        s->rwait++;
    } else {
        printf("\nReader Process added.\n");
        s->rcount++;
        s->mutex--;
    }
    return;
}

// Function to add a writer
void addW(struct semaphore *s) {
    if (s->mutex == 1) {
        s->mutex--;
        s->wrt = 1;
        printf("\nWriter Process added.\n");
    } else if (s->wrt)
        printf("\nSorry, Writer already operational.\n");
    else
        printf("\nSorry, File open in Read mode.\n");
    return;
}

// Function to remove a reader
void remR(struct semaphore *s) {
    if (s->rcount == 0)
        printf("\nNo readers to remove.\n");
    else {
        printf("\nReader Removed.\n");
        s->rcount--;
        s->mutex++;
    }
    return;
}

// Function to remove a writer
void remW(struct semaphore *s) {
    if (s->wrt == 0)
        printf("\nNo Writer to Remove\n");
    else {
        printf("\nWriter Removed\n");
        s->mutex++;
        s->wrt = 0;
        if (s->rwait != 0) {
            s->mutex -= s->rwait;  // Allow waiting readers to proceed
            s->rcount = s->rwait;   // Set active readers count to waiting
            s->rwait = 0;           // Reset waiting readers count
            printf("%d waiting Readers Added.\n", s->rcount);
        }
    }
}

// Function to simulate various cases
void simulate(struct semaphore *s) {
    // Simulating adding 2 readers
    addR(s);  // Reader 1
    addR(s);  // Reader 2

    // Simulating adding a writer
    addW(s);  // Writer 1

    // Simulating removing 1 reader
    remR(s);  // Reader 1

    // Simulating adding 1 more reader
    addR(s);  // Reader 3

    // Simulating removing the writer
    remW(s);  // Writer 1

    // Simulating adding another reader and writer
    addR(s);  // Reader 4
    addW(s);  // Writer 2

    // Simulating removing all readers
    remR(s);  // Reader 2
    remR(s);  // Reader 3
    remR(s);  // Reader 4
}

int main() {
    struct semaphore S1 = {1, 0, 0, false}; // Initialize semaphore
    
    // Simulate predefined cases
    simulate(&S1);

    // Final state of the semaphore
    printf("\nFinal State ->\n\tMutex\t\t:\t%d\n\tActive Readers\t:\t%d\n\tWaiting Readers\t:\t%d\n\tWriter Active\t:\t%s\n\n",
           S1.mutex, S1.rcount, S1.rwait, (S1.wrt ? "YES" : "NO"));
    
    return 0;
}





-----------------------------------------------------------------------------------------

Q. Readers-Writers Problem using Threads and Semaphore

CODE - 
#include <pthread.h>
#include <stdio.h>
#include <semaphore.h>
#include <stdlib.h>

sem_t resource;        // Semaphore for the shared resource
sem_t read_count_mutex; // Semaphore to protect read_count
int read_count = 0;    // Number of readers currently reading
int shared_data = 0;   // Shared resource

// Reader function
void* reader(void* arg) {
    int reader_id = *((int*)arg);

    // Reader entry section
    sem_wait(&read_count_mutex);
    read_count++;
    if (read_count == 1) {
        printf("Reader %d is the first reader. Locking the resource.\n", reader_id);
        sem_wait(&resource); // First reader locks the resource
    }
    sem_post(&read_count_mutex);

    // Reading the shared resource
    printf("Reader %d is reading the shared data: %d\n", reader_id, shared_data);

    // Reader exit section
    sem_wait(&read_count_mutex);
    read_count--;
    if (read_count == 0) {
        printf("Reader %d is the last reader. Unlocking the resource.\n", reader_id);
        sem_post(&resource); // Last reader unlocks the resource
    }
    sem_post(&read_count_mutex);

    pthread_exit(0);
}

// Writer function
void* writer(void* arg) {
    int writer_id = *((int*)arg);

    // Writer entry section
    printf("Writer %d is trying to lock the resource.\n", writer_id);
    sem_wait(&resource);

    // Writing to the shared resource
    shared_data++;
    printf("Writer %d is writing new data: %d\n", writer_id, shared_data);

    // Writer exit section
    printf("Writer %d is unlocking the resource.\n", writer_id);
    sem_post(&resource);

    pthread_exit(0);
}

int main() {
    pthread_t readers[5], writers[3];
    int reader_ids[5], writer_ids[3];

    // Initialize semaphores
    sem_init(&resource, 0, 1);       // Binary semaphore for the shared resource
    sem_init(&read_count_mutex, 0, 1); // Binary semaphore for read_count_mutex

    // Create 5 reader threads
    for (int i = 0; i < 5; i++) {
        reader_ids[i] = i + 1;
        pthread_create(&readers[i], NULL, reader, &reader_ids[i]);
    }

    // Create 3 writer threads
    for (int i = 0; i < 3; i++) {
        writer_ids[i] = i + 1;
        pthread_create(&writers[i], NULL, writer, &writer_ids[i]);
    }

    // Wait for all readers to finish
    for (int i = 0; i < 5; i++) {
        pthread_join(readers[i], NULL);
    }

    // Wait for all writers to finish
    for (int i = 0; i < 3; i++) {
        pthread_join(writers[i], NULL);
    }

    // Destroy semaphores
    sem_destroy(&resource);
    sem_destroy(&read_count_mutex);

    return 0;
}








