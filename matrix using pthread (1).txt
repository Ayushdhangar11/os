#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define MAX_SIZE 10

int matrixA[MAX_SIZE][MAX_SIZE], matrixB[MAX_SIZE][MAX_SIZE], result[MAX_SIZE][MAX_SIZE];
int numRows = 3, numCols = 3, numThreads = 3;  // Predefined number of rows, columns, and threads

void initializeMatrices() {
    // Initialize Matrix A (3x3)
    int A[3][3] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    // Initialize Matrix B (3x3)
    int B[3][3] = {
        {9, 8, 7},
        {6, 5, 4},
        {3, 2, 1}
    };

    // Copy data to matrixA and matrixB
    for (int i = 0; i < numRows; i++) {
        for (int j = 0; j < numCols; j++) {
            matrixA[i][j] = A[i][j];
            matrixB[i][j] = B[i][j];
        }
    }
}

void printMatrix(int matrix[MAX_SIZE][MAX_SIZE]) {
    for (int i = 0; i < numRows; i++) {
        for (int j = 0; j < numCols; j++) {
            printf("%4d", matrix[i][j]);
        }
        printf("\n");
    }
}

void* matrixMultiply(void* arg) {
    int threadId = *((int*)arg); // Cast the argument to the correct type
    int startRow = (threadId * numRows) / numThreads;
    int endRow = ((threadId + 1) * numRows) / numThreads;

    for (int i = startRow; i < endRow; i++) {
        for (int j = 0; j < numCols; j++) {
            result[i][j] = 0;
            for (int k = 0; k < numCols; k++) {
                result[i][j] += matrixA[i][k] * matrixB[k][j];
            }
        }
    }

    return NULL;
}

void* matrixAdd(void* arg) {
    int threadId = *((int*)arg); // Cast the argument to the correct type
    int startRow = (threadId * numRows) / numThreads;
    int endRow = ((threadId + 1) * numRows) / numThreads;

    for (int i = startRow; i < endRow; i++) {
        for (int j = 0; j < numCols; j++) {
            result[i][j] = matrixA[i][j] + matrixB[i][j];
        }
    }

    return NULL;
}

void* matrixSubtract(void* arg) {
    int threadId = *((int*)arg); // Cast the argument to the correct type
    int startRow = (threadId * numRows) / numThreads;
    int endRow = ((threadId + 1) * numRows) / numThreads;

    for (int i = startRow; i < endRow; i++) {
        for (int j = 0; j < numCols; j++) {
            result[i][j] = matrixA[i][j] - matrixB[i][j];
        }
    }

    return NULL;
}

int main() {
    // Initialize the matrices
    initializeMatrices();

    // Print original matrices
    printf("Matrix A:\n");
    printMatrix(matrixA);

    printf("\nMatrix B:\n");
    printMatrix(matrixB);

    // Simulation for Addition
    int operation = 1;  // Set to 1 for Addition, 2 for Subtraction, 3 for Multiplication
    void* (*operationFunction)(void*);
    
    switch (operation) {
        case 1:
            operationFunction = matrixAdd;
            break;
        case 2:
            operationFunction = matrixSubtract;
            break;
        case 3:
            operationFunction = matrixMultiply;
            break;
        default:
            printf("Invalid choice.\n");
            return 1;
    }

    // Create threads to perform the matrix operation
    pthread_t threads[numThreads];
    for (int i = 0; i < numThreads; i++) {
        int* threadId = (int*)malloc(sizeof(int)); // Allocate memory for thread ID
        *threadId = i; // Assign the thread id
        pthread_create(&threads[i], NULL, operationFunction, (void*)threadId);
    }

    // Wait for all threads to complete
    for (int i = 0; i < numThreads; i++) {
        pthread_join(threads[i], NULL);
    }

    // Print the resulting matrix for the selected operation
    printf("\nResultant Matrix (Addition):\n");
    printMatrix(result);

    // Reinitialize result for subtraction and multiplication simulations
    initializeMatrices();

    // Simulation for Subtraction
    operation = 2;  // Set to 1 for Addition, 2 for Subtraction, 3 for Multiplication
    switch (operation) {
        case 1:
            operationFunction = matrixAdd;
            break;
        case 2:
            operationFunction = matrixSubtract;
            break;
        case 3:
            operationFunction = matrixMultiply;
            break;
        default:
            printf("Invalid choice.\n");
            return 1;
    }

    // Create threads for subtraction
    for (int i = 0; i < numThreads; i++) {
        int* threadId = (int*)malloc(sizeof(int)); // Allocate memory for thread ID
        *threadId = i; // Assign the thread id
        pthread_create(&threads[i], NULL, operationFunction, (void*)threadId);
    }

    // Wait for all threads to complete
    for (int i = 0; i < numThreads; i++) {
        pthread_join(threads[i], NULL);
    }

    // Print the resulting matrix for subtraction
    printf("\nResultant Matrix (Subtraction):\n");
    printMatrix(result);

    // Reinitialize result for multiplication simulation
    initializeMatrices();

    // Simulation for Multiplication
    operation = 3;  // Set to 1 for Addition, 2 for Subtraction, 3 for Multiplication
    switch (operation) {
        case 1:
            operationFunction = matrixAdd;
            break;
        case 2:
            operationFunction = matrixSubtract;
            break;
        case 3:
            operationFunction = matrixMultiply;
            break;
        default:
            printf("Invalid choice.\n");
            return 1;
    }

    // Create threads for multiplication
    for (int i = 0; i < numThreads; i++) {
        int* threadId = (int*)malloc(sizeof(int)); // Allocate memory for thread ID
        *threadId = i; // Assign the thread id
        pthread_create(&threads[i], NULL, operationFunction, (void*)threadId);
    }

    // Wait for all threads to complete
    for (int i = 0; i < numThreads; i++) {
        pthread_join(threads[i], NULL);
    }

    // Print the resulting matrix for multiplication
    printf("\nResultant Matrix (Multiplication):\n");
    printMatrix(result);

    return 0;
}
