15. #include <iostream>
#include <vector>
#include <queue>
#include <unordered_set>


using namespace std;


// Function to calculate page faults using FIFO page replacement
int calculatePageFaults(const vector<int> &pages, int frameSize) {
    unordered_set<int> frames;
    queue<int> indexQueue; // To keep track of the order of pages for FIFO
    int pageFaults = 0;


    for (int page : pages) {
        // If page is not in frame, we have a page fault
        if (frames.find(page) == frames.end()) {
            // If frame is full, remove the oldest page (FIFO order)
            if (frames.size() == frameSize) {
                int oldestPage = indexQueue.front();
                indexQueue.pop();
                frames.erase(oldestPage);
            }
            // Insert the current page and update structures
            frames.insert(page);
            indexQueue.push(page);
            pageFaults++;
        }
    }
    return pageFaults;
}


int main() {
    int n, frameSize;


    cout << "Enter the number of pages in the reference string: ";
    cin >> n;
    vector<int> pages(n);


    cout << "Enter the reference string: ";
    for (int i = 0; i < n; i++) {
        cin >> pages[i];
    }


    cout << "Enter the number of frames: ";
    cin >> frameSize;


    int pageFaults = calculatePageFaults(pages, frameSize);
    cout << "Number of page faults: " << pageFaults << endl;


    return 0;
}

### Explanation of the Code

The given C++ program implements the **First-In-First-Out (FIFO) page replacement algorithm** to simulate page faults in a virtual memory system. The FIFO algorithm is one of the simplest page replacement algorithms used by operating systems when there are more processes or pages than physical memory frames. This program calculates the number of page faults when accessing a series of pages with a given number of memory frames.

### Key Concepts in Operating Systems (OS)

1. **Page Fault**:
   - A **page fault** occurs when a process tries to access a page that is not currently in memory. This triggers the operating system to load the page from disk into memory. Page faults are costly because disk I/O is much slower than accessing memory, so minimizing page faults is important for system performance.

2. **Page Replacement Algorithms**:
   - **Page replacement algorithms** are used to manage the contents of the memory frames when a new page needs to be loaded but there is no free space in memory. These algorithms decide which page to remove from memory to make space for the new one.
   - The **FIFO** (First-In-First-Out) algorithm is one of the simplest page replacement algorithms, where the oldest page in memory is replaced with the new page when a page fault occurs.

3. **Memory Frames**:
   - **Frames** refer to fixed-size blocks of physical memory. When a program needs to access data, it refers to pages. If the page is not in the physical memory (a page fault), it must be brought into a frame.

4. **Page Reference String**:
   - The **page reference string** is a sequence of page numbers that represent the pages a program accesses during execution.

### Data Structures Used in the Code

1. **unordered_set<int> frames**:
   - This data structure is used to keep track of the pages that are currently in the memory frames. The `unordered_set` allows for fast look-up and insertion operations, which helps quickly determine if a page is already in memory.
   
2. **queue<int> indexQueue**:
   - The queue is used to keep track of the order in which pages were loaded into memory. In FIFO, the page that was loaded first is the one that will be removed when memory is full.

3. **int pageFaults**:
   - This variable is used to count the number of page faults that occur during the execution of the page reference string.

### Code Walkthrough

1. **Input**:
   - The program begins by reading the number of pages (`n`) in the reference string and the size of the memory frames (`frameSize`).
   - It then takes the actual page reference string, i.e., the sequence of page accesses, and stores it in the `pages` vector.

2. **FIFO Page Replacement Algorithm** (`calculatePageFaults`):
   - The function `calculatePageFaults` takes the page reference string and the number of frames as input and returns the number of page faults that occur during the execution.
   
   - **Initialization**:
     - `frames`: A set that keeps track of the pages currently in memory.
     - `indexQueue`: A queue that maintains the order of pages as they are added to memory (used for FIFO).
     - `pageFaults`: A counter that tracks the number of page faults that occur.

   - **Processing Pages**:
     - For each page in the reference string:
       - **Page Fault**: If the page is not found in `frames`, it results in a page fault.
         - If the memory is full (i.e., the size of `frames` equals `frameSize`), the oldest page (the page that was added first) is removed from memory. This is done using the `indexQueue` (FIFO).
         - After removing the oldest page, the new page is added to both `frames` and `indexQueue`, and the `pageFaults` counter is incremented.
       - **No Page Fault**: If the page is already present in memory, no page fault occurs.

3. **Output**:
   - After processing all the pages, the program outputs the total number of page faults that occurred during the execution of the reference string.

### Theory Behind FIFO Page Replacement Algorithm

The **FIFO page replacement algorithm** works by maintaining a queue of pages that are currently loaded into memory. The key idea behind FIFO is that the page that has been in memory the longest (i.e., the page at the front of the queue) will be the first one to be replaced when a new page needs to be loaded. This strategy is simple but can be inefficient in some cases, as it does not always take into account which pages are actually used more frequently.

Here’s how FIFO works:

1. When a page is referenced, the operating system checks if it is already in memory.
2. If the page is not in memory (i.e., a **page fault**), and there is space in memory, the page is simply loaded into an empty frame.
3. If the page is not in memory and there is no space, the **oldest page** (the one that has been in memory the longest) is replaced with the new page. This is done by removing the page from the front of the queue and inserting the new page at the back of the queue.

### Limitations of FIFO

- **Belady’s Anomaly**: One of the drawbacks of the FIFO algorithm is **Belady's anomaly**, which is the phenomenon where increasing the number of frames can sometimes increase the number of page faults, which is counter-intuitive. FIFO does not take into account the future use of pages, leading to suboptimal decisions.
- **No consideration for page usage**: FIFO only considers the order of page loading, not how frequently pages are accessed. This can lead to situations where frequently used pages are replaced prematurely.

### Conclusion

The program calculates the number of page faults in a system using the FIFO page replacement algorithm. It does so by simulating the page replacement process, maintaining the memory state, and tracking page faults. FIFO is simple to implement but has some limitations, such as Belady’s anomaly, which make it less efficient compared to other algorithms like **LRU** (Least Recently Used) or **Optimal page replacement**. However, it remains a fundamental algorithm for understanding basic memory management in operating systems.
